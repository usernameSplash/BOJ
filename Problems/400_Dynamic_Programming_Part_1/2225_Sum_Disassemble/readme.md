## 합분해

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구해야 한다.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.


## 풀이

`dp[n][k]` = 정수 n을 k개의 숫자로 만드는 경우의 수

`dp[n-i][k-1]` 정수 (n-i)을 (k-1)개의 숫자로 만드는 경우의 수에서, 정수 i를 합에 포함하면 정수 n을 k개의 숫자로 만드는 경우의 수가 된다.

유효한 범위 내의 정수 i들에 대한, 모든 `dp[n-i][k-1]`들을 합치면 됨.

## 풀이 2

`dp[n-1][k]` = 정수 n-1을 k개의 숫자로 만드는 방법 : 해당 방법을 구성하는 각각의 합분해의 결과에서, 마지막 항을 `+1`한 결과로 해 주면 된다.
    - 예 : 2를 정수 2개로 구성하는 방법은 `(0+2)`, `(1+1)`, `(2+0)`이 있다. 마지막 항을 각각 `+1` 해주면 `(0+3)`, `(1+2)`, `(2+1)`이 된다.

`dp[n][k-1]` = 정수 n을 k-1개의 숫자로 만드는 방법 : 해당 방법 맨 뒤에 `+0` 항을 붙이면 k개의 숫자로 만드는 것이 된다.
    - 예 : 3을 정수 1개로 구성하는 방법은 `(3)`이다. 마지막에 0을 붙이면 `(3+0)`이 된다.

따라서 `dp[3][2] = 4`이다.

`dp[i][j] = (dp[i-1][j] + dp[i][j-1])`

나는 처음에 풀이 1의 방법으로 생각해서 구현하다가, 풀이 2가 생각나서 2로 진행했다. 코드가 좀 더 깔끔해서.